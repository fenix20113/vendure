/**
 * Builds a tree from an array of nodes which have a parent.
 * Based on https://stackoverflow.com/a/31247960/772859, modified to preserve ordering.
 */
export function arrayToTree(nodes, currentState) {
    var _a, _b;
    const topLevelNodes = [];
    const mappedArr = {};
    const currentStateMap = treeToMap(currentState);
    // First map the nodes of the array to an object -> create a hash table.
    for (const node of nodes) {
        mappedArr[node.id] = Object.assign(Object.assign({}, node), { children: [] });
    }
    for (const id of nodes.map(n => n.id)) {
        if (mappedArr.hasOwnProperty(id)) {
            const mappedElem = mappedArr[id];
            mappedElem.expanded = (_b = (_a = currentStateMap.get(id)) === null || _a === void 0 ? void 0 : _a.expanded) !== null && _b !== void 0 ? _b : false;
            const parent = mappedElem.parent;
            if (!parent) {
                continue;
            }
            // If the element is not at the root level, add it to its parent array of children.
            const parentIsRoot = !mappedArr[parent.id];
            if (!parentIsRoot) {
                if (mappedArr[parent.id]) {
                    mappedArr[parent.id].children.push(mappedElem);
                }
                else {
                    mappedArr[parent.id] = { children: [mappedElem] };
                }
            }
            else {
                topLevelNodes.push(mappedElem);
            }
        }
    }
    // tslint:disable-next-line:no-non-null-assertion
    const rootId = topLevelNodes.length ? topLevelNodes[0].parent.id : undefined;
    return { id: rootId, children: topLevelNodes };
}
/**
 * Converts an existing tree (as generated by the arrayToTree function) into a flat
 * Map. This is used to persist certain states (e.g. `expanded`) when re-building the
 * tree.
 */
function treeToMap(tree) {
    const nodeMap = new Map();
    function visit(node) {
        nodeMap.set(node.id, node);
        node.children.forEach(visit);
    }
    if (tree) {
        visit(tree);
    }
    return nodeMap;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXktdG8tdHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvY29tcG9uZW50cy9jb2xsZWN0aW9uLXRyZWUvYXJyYXktdG8tdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQTs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUFzQixLQUFVLEVBQUUsWUFBMEI7O0lBQ25GLE1BQU0sYUFBYSxHQUF1QixFQUFFLENBQUM7SUFDN0MsTUFBTSxTQUFTLEdBQWtDLEVBQUUsQ0FBQztJQUNwRCxNQUFNLGVBQWUsR0FBRyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7SUFFaEQsd0VBQXdFO0lBQ3hFLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1FBQ3RCLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLG1DQUFTLElBQVksS0FBRSxRQUFRLEVBQUUsRUFBRSxHQUFFLENBQUM7S0FDM0Q7SUFFRCxLQUFLLE1BQU0sRUFBRSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDbkMsSUFBSSxTQUFTLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQzlCLE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNqQyxVQUFVLENBQUMsUUFBUSxlQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLDBDQUFFLFFBQVEsbUNBQUksS0FBSyxDQUFDO1lBQ2pFLE1BQU0sTUFBTSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUM7WUFDakMsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDVCxTQUFTO2FBQ1o7WUFDRCxtRkFBbUY7WUFDbkYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzNDLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ2YsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUN0QixTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQ2xEO3FCQUFNO29CQUNILFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBUyxDQUFDO2lCQUM1RDthQUNKO2lCQUFNO2dCQUNILGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDbEM7U0FDSjtLQUNKO0lBQ0QsaURBQWlEO0lBQ2pELE1BQU0sTUFBTSxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDOUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxDQUFDO0FBQ25ELENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxTQUFTLENBQXNCLElBQWtCO0lBQ3RELE1BQU0sT0FBTyxHQUFHLElBQUksR0FBRyxFQUF1QixDQUFDO0lBQy9DLFNBQVMsS0FBSyxDQUFDLElBQWlCO1FBQzVCLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQ0QsSUFBSSxJQUFJLEVBQUU7UUFDTixLQUFLLENBQUMsSUFBbUIsQ0FBQyxDQUFDO0tBQzlCO0lBQ0QsT0FBTyxPQUFPLENBQUM7QUFDbkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIEhhc1BhcmVudCA9IHsgaWQ6IHN0cmluZzsgcGFyZW50PzogeyBpZDogc3RyaW5nIH0gfCBudWxsIH07XG5leHBvcnQgdHlwZSBUcmVlTm9kZTxUIGV4dGVuZHMgSGFzUGFyZW50PiA9IFQgJiB7IGNoaWxkcmVuOiBBcnJheTxUcmVlTm9kZTxUPj47IGV4cGFuZGVkOiBib29sZWFuIH07XG5leHBvcnQgdHlwZSBSb290Tm9kZTxUIGV4dGVuZHMgSGFzUGFyZW50PiA9IHsgaWQ/OiBzdHJpbmc7IGNoaWxkcmVuOiBBcnJheTxUcmVlTm9kZTxUPj4gfTtcblxuLyoqXG4gKiBCdWlsZHMgYSB0cmVlIGZyb20gYW4gYXJyYXkgb2Ygbm9kZXMgd2hpY2ggaGF2ZSBhIHBhcmVudC5cbiAqIEJhc2VkIG9uIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTI0Nzk2MC83NzI4NTksIG1vZGlmaWVkIHRvIHByZXNlcnZlIG9yZGVyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUb1RyZWU8VCBleHRlbmRzIEhhc1BhcmVudD4obm9kZXM6IFRbXSwgY3VycmVudFN0YXRlPzogUm9vdE5vZGU8VD4pOiBSb290Tm9kZTxUPiB7XG4gICAgY29uc3QgdG9wTGV2ZWxOb2RlczogQXJyYXk8VHJlZU5vZGU8VD4+ID0gW107XG4gICAgY29uc3QgbWFwcGVkQXJyOiB7IFtpZDogc3RyaW5nXTogVHJlZU5vZGU8VD4gfSA9IHt9O1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZU1hcCA9IHRyZWVUb01hcChjdXJyZW50U3RhdGUpO1xuXG4gICAgLy8gRmlyc3QgbWFwIHRoZSBub2RlcyBvZiB0aGUgYXJyYXkgdG8gYW4gb2JqZWN0IC0+IGNyZWF0ZSBhIGhhc2ggdGFibGUuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG1hcHBlZEFycltub2RlLmlkXSA9IHsgLi4uKG5vZGUgYXMgYW55KSwgY2hpbGRyZW46IFtdIH07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpZCBvZiBub2Rlcy5tYXAobiA9PiBuLmlkKSkge1xuICAgICAgICBpZiAobWFwcGVkQXJyLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGVkRWxlbSA9IG1hcHBlZEFycltpZF07XG4gICAgICAgICAgICBtYXBwZWRFbGVtLmV4cGFuZGVkID0gY3VycmVudFN0YXRlTWFwLmdldChpZCk/LmV4cGFuZGVkID8/IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbWFwcGVkRWxlbS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgbm90IGF0IHRoZSByb290IGxldmVsLCBhZGQgaXQgdG8gaXRzIHBhcmVudCBhcnJheSBvZiBjaGlsZHJlbi5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudElzUm9vdCA9ICFtYXBwZWRBcnJbcGFyZW50LmlkXTtcbiAgICAgICAgICAgIGlmICghcGFyZW50SXNSb290KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZEFycltwYXJlbnQuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZEFycltwYXJlbnQuaWRdLmNoaWxkcmVuLnB1c2gobWFwcGVkRWxlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVkQXJyW3BhcmVudC5pZF0gPSB7IGNoaWxkcmVuOiBbbWFwcGVkRWxlbV0gfSBhcyBhbnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbE5vZGVzLnB1c2gobWFwcGVkRWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IHJvb3RJZCA9IHRvcExldmVsTm9kZXMubGVuZ3RoID8gdG9wTGV2ZWxOb2Rlc1swXS5wYXJlbnQhLmlkIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IGlkOiByb290SWQsIGNoaWxkcmVuOiB0b3BMZXZlbE5vZGVzIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gZXhpc3RpbmcgdHJlZSAoYXMgZ2VuZXJhdGVkIGJ5IHRoZSBhcnJheVRvVHJlZSBmdW5jdGlvbikgaW50byBhIGZsYXRcbiAqIE1hcC4gVGhpcyBpcyB1c2VkIHRvIHBlcnNpc3QgY2VydGFpbiBzdGF0ZXMgKGUuZy4gYGV4cGFuZGVkYCkgd2hlbiByZS1idWlsZGluZyB0aGVcbiAqIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyZWVUb01hcDxUIGV4dGVuZHMgSGFzUGFyZW50Pih0cmVlPzogUm9vdE5vZGU8VD4pOiBNYXA8c3RyaW5nLCBUcmVlTm9kZTxUPj4ge1xuICAgIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwPHN0cmluZywgVHJlZU5vZGU8VD4+KCk7XG4gICAgZnVuY3Rpb24gdmlzaXQobm9kZTogVHJlZU5vZGU8VD4pIHtcbiAgICAgICAgbm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCh2aXNpdCk7XG4gICAgfVxuICAgIGlmICh0cmVlKSB7XG4gICAgICAgIHZpc2l0KHRyZWUgYXMgVHJlZU5vZGU8VD4pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZU1hcDtcbn1cbiJdfQ==